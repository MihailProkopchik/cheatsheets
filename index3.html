<!DOCTYPE html>
<html lang="ru">
    <head>
        <link rel="stylesheet" href="./style3.css" />
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Операторы сравнения</title>
    </head>
    <body>
    <section class="comparison_operators">
        <h1>Операторы сравнения</h1>
        <p>
            Многие операторы сравнения известны нам из математики.,<br><br>
            В JavaScript они записываются так:<br><br>
            <ul>
               <li> Больше/меньше: <b>a > b, a < b.</b></li>
               <li>Больше/меньше или равно: <b>a >= b, a <= b.</b></li>
                <li>Равно: <b>a == b</b>. Обратите внимание, для сравнения используется двойной знак равенства ==. Один знак равенства <b> a = b </b>означал бы присваивание.</li>
                <li> Не равно. В математике обозначается символом <b>≠</b>, но в JavaScript записывается как <b>a != b.</b></li>
            </ul>
        </p>
    </section>
    <section class="boolean_type">
        <h2>Результат сравнения имеет логический тип</h2>
        <p>Все операторы сравнения возвращают значение логического типа:<br><br>
        <b>true</b> – означает «да», «верно», «истина».<br><br>
        <b>false</b> – означает «нет», «неверно», «ложь».
        </p>
    </section >
    <section class="String_comparison">
        <h2>Сравнение строк</h2>
        <p>
            Чтобы определить, что одна строка больше другой, JavaScript использует «алфавитный» или «лексикографический» порядок.<br><br>
            Другими словами, строки сравниваются посимвольно.<br><br>
            Например:<br><br>            
            alert( 'Я' > 'А' ); // true<br>
            alert( 'Коты' > 'Кода' ); // true<br>
            alert( 'Сонный' > 'Сон' ); // true<br><br>
            Алгоритм сравнения двух строк довольно прост: <br>  
            <ol>      
                <li>Сначала сравниваются первые символы строк.</li><br>
                <li>Если первый символ первой строки больше (меньше), чем первый символ второй, то первая строка больше(меньше) второй. Сравнение завершено.</li><br>
                <li>Если первые символы равны, то таким же образом сравниваются уже вторые символы строк.</li><br>
                <li>Сравнение продолжается, пока не закончится одна из строк.</li><br>
                <li>Если обе строки заканчиваются одновременно,то они равны. Иначе,большей считается более длинная строка</li>
            </ul>
        </p>
    </section>
    <section  class="types"> 
        <h2>Сравнение разных типов</h2>
        <p>
            При сравнении значений разных типов JavaScript приводит каждое из них к числу.<br><br>
            Например:<br><br>
            alert( '2' > 1 ); // true, строка '2' становится числом 2<br>
            alert( '01' == 1 ); // true, строка '01' становится числом 1<br><br>
            Логическое значение <b>true</b> становится <b>1</b>, а <b>false – 0</b>.
            Например:<br><br>
            alert( true == 1 ); // true<br>
            alert( false == 0 ); // true
        </p>
    </section>
    <section class="strict_comparison">
        <h2>Строгое сравнение</h2>
        <p >
            <b>Оператор строгого равенства <em>===</em> проверяет равенство без приведения типов.</b><br><br>
            Другими словами, если <b>a</b> и <b>b</b> имеют разные типы, то проверка <b>a === b</b> немедленно возвращает <b>false</b> без попытки их преобразования.<br><br>
            Давайте проверим:<br><br>
            alert( 0 === false ); // false, так как сравниваются разные типы<br><br>
            Ещё есть оператор строгого неравенства <b>!==</b>, аналогичный <b>!=</b>.
        </p>
    </section>
    <section class="null_undefined">
    <h2>Сравнение с null и undefined</h2>
    <p >
    <b>При строгом равенстве <em>===</em></b><br><br>
        Эти значения различны, так как различны их типы.<br><br>
        alert( null === undefined ); // false<br><br>
    <b> При нестрогом равенстве <em>==</em></b><br><br>
        Эти значения равны друг другу и не равны никаким другим значениям. Это специальное правило языка.<br><br>
        alert( null == undefined ); // true<br><br>
    <b>При использовании математических операторов и других операторов сравнения <em>< > <= >=</em></b><br>
        Значения <b>null/undefined</b> преобразуются к числам: <b>null</b> становится <b>0</b>, а <b>undefined – NaN</b>.
        <h2>Странный результат сравнения null и 0</h2>
        Сравним <b>null</b> с нулём:<br><br>
        alert( null > 0 );  // (1) false<br>
        alert( null == 0 ); // (2) false<br>
        alert( null >= 0 ); // (3) true<br><br>
        С точки зрения математики это странно. Результат последнего сравнения говорит о том, что "<b>null</b> больше или равно нулю", тогда результат одного из сравнений выше должен быть <b>true</b>, но они оба ложны.
        Причина в том, что нестрогое равенство и сравнения <b>> < >= <=</b> работают по-разному. Сравнения преобразуют <b>null</b> в число, рассматривая его как 0. Поэтому выражение (3) <b>null >= 0</b> истинно, а <b>null > 0</b> ложно.
        С другой стороны, для нестрогого равенства <b>==</b> значений <b>undefined</b> и <b>null</b> действует особое правило: эти значения ни к чему не приводятся, они равны друг другу и не равны ничему другому. Поэтому (2) <b>null == 0</b> ложно.
    </p>
</section>
<section class="total">
</p>
</section>