<!DOCTYPE html>
<html lang="ru">
    <head>
        <link rel="stylesheet" href="./style3.css" />
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Операторы сравнения</title>
    </head>
    <body>
    <section class="comparison_operators">
        <h1>Операторы сравнения</h1>
        <p>
            Многие операторы сравнения известны нам из математики.,<br><br>
            В JavaScript они записываются так:<br><br>
            <ul>
               <li> Больше/меньше: <b>a > b, a < b.</b></li><br><br>
               <li>Больше/меньше или равно: <b>a >= b, a <= b.</b></li><br><br>
                <li>Равно: <b>a == b</b>. Обратите внимание, для сравнения используется двойной знак равенства ==. Один знак равенства <b> a = b </b>означал бы присваивание.</li><br><br>
                <li> Не равно. В математике обозначается символом <b>≠</b>, но в JavaScript записывается как <b>a != b.</b></li><br><br>
            </ul>
            В этом разделе мы больше узнаем про то, какие бывают сравнения, как язык с ними работает и к каким неожиданностям мы должны быть готовы.
            В конце вы найдёте хороший рецепт того, как избегать «причуд» сравнения в JavaScript.
        </p>
    </section>
    <section class="boolean_type">
        <h2>Результат сравнения имеет логический тип</h2>
        <p>Все операторы сравнения возвращают значение логического типа:<br><br>
        <b>true</b> – означает «да», «верно», «истина».<br><br>
        <b>false</b> – означает «нет», «неверно», «ложь».<br><br>
            Например:<br><br>
            alert( 2 > 1 );  // true (верно)<br>
            alert( 2 == 1 ); // false (неверно)<br>
            alert( 2 != 1 ); // true (верно)<br><br>
            Результат сравнения можно присвоить переменной, как и любое значение:<br><br>
            let result = 5 > 4; // результат сравнения присваивается переменной result<br>
            alert( result ); // true<br><br>
            
        </p>
    </section >
    <section class="String_comparison">
        <h2>Сравнение строк</h2>
        <p>
            Чтобы определить, что одна строка больше другой, JavaScript использует «алфавитный» или «лексикографический» порядок.<br><br>
            Другими словами, строки сравниваются посимвольно.<br><br>
            Например:<br><br>            
            alert( 'Я' > 'А' ); // true<br>
            alert( 'Коты' > 'Кода' ); // true<br>
            alert( 'Сонный' > 'Сон' ); // true<br><br>
            Алгоритм сравнения двух строк довольно прост: <br><br>     
            <ol>      
                <li>Сначала сравниваются первые символы строк.</li><br>
                <li>Если первый символ первой строки больше (меньше), чем первый символ второй, то первая строка больше(меньше) второй. Сравнение завершено.</li><br>
                <li>Если первые символы равны, то таким же образом сравниваются уже вторые символы строк.</li><br>
                <li>Сравнение продолжается, пока не закончится одна из строк.</li><br>
                <li>Если обе строки заканчиваются одновременно,то они равны. Иначе,большей считается более длинная строка</li><br><br>
            </ul>
            В примерах выше сравнение <b>'Я' > 'А'</b> завершится на первом шаге, тогда как строки <b>'Коты'</b> и <b>'Кода'</b> будут сравниваться посимвольно:<br><br>   
            <ol>      
            <li><b>К</b> равна <b>К</b>.</li><br> 
            <li><b>о</b> равна <b>о</b>.</li><br> 
            <li><b>т</b> больше, чем <b>д</b>. На этом сравнение заканчивается. Первая строка больше.</li><br> <br> 
            </ol>   
        </p>
    </section>
    <section  class="types"> 
        <h2>Сравнение разных типов</h2>
        <p>
            При сравнении значений разных типов JavaScript приводит каждое из них к числу.<br><br>
            Например:<br><br>
            alert( '2' > 1 ); // true, строка '2' становится числом 2<br>
            alert( '01' == 1 ); // true, строка '01' становится числом 1<br><br>
            Логическое значение <b>true</b> становится <b>1</b>, а <b>false – 0</b>.
            Например:<br><br>
            alert( true == 1 ); // true<br>
            alert( false == 0 ); // true<br><br>
            Забавное следствие<br><br>
            Возможна следующая ситуация:<br><br>
            Два значения равны.<br>
            Одно из них <b>true</b> как логическое значение, другое – <b>false</b>.<br><br>
            Например:<br><br>
            let a = 0;<br>
            alert( Boolean(a) ); // false<br>
            let b = "0";<br>
            alert( Boolean(b) ); // true<br>
            alert(a == b); // true!<br><br>
            С точки зрения JavaScript, результат ожидаем. Равенство преобразует значения, используя числовое преобразование, поэтому <b>"0"</b> становится <b>0</b>. В то время как явное преобразование с помощью <b>Boolean</b> использует другой набор правил.
        </p>
    </section>
    <section class="strict_comparison">
        <h2>Строгое сравнение</h2>
        <p >
            Использование обычного сравнения <b>==</b> может вызывать проблемы. Например, оно не отличает <b>0</b> от <b>false</b>:<br><br>
            alert( 0 == false ); // true<br><br>
            Та же проблема с пустой строкой:<br><br>
            alert( '' == false ); // true<br><br>
            Это происходит из-за того, что операнды разных типов преобразуются оператором <b>==</b> к числу. В итоге, и пустая строка, и <b>false</b> становятся нулём.<br><br>
            Как же тогда отличать <b>0</b> от <b>false</b>?<br><br>
            <b>Оператор строгого равенства <em>===</em> проверяет равенство без приведения типов.</b><br><br>
            Другими словами, если <b>a</b> и <b>b</b> имеют разные типы, то проверка <b>a === b</b> немедленно возвращает <b>false</b> без попытки их преобразования.<br><br>
            Давайте проверим:<br><br>
            alert( 0 === false ); // false, так как сравниваются разные типы<br><br>
            Ещё есть оператор строгого неравенства <b>!==</b>, аналогичный <b>!=</b>.<br><br>
            Оператор строгого равенства дольше писать, но он делает код более очевидным и оставляет меньше места для ошибок.
        </p>
    </section>
    <section class="null_undefined">
    <h2>Сравнение с null и undefined</h2>
    <p >
        Поведение </b>null</b> и </b>undefined</b> при сравнении с другими значениями — особое:<br><br>
    <b>При строгом равенстве <em>===</em></b><br><br>
        Эти значения различны, так как различны их типы.<br><br>
        alert( null === undefined ); // false<br><br>
    <b> При нестрогом равенстве <em>==</em></b><br><br>
        Эти значения равны друг другу и не равны никаким другим значениям. Это специальное правило языка.<br><br>
        alert( null == undefined ); // true<br><br>
    <b>При использовании математических операторов и других операторов сравнения <em>< > <= >=</em></b><br>
        Значения <b>null/undefined</b> преобразуются к числам: <b>null</b> становится <b>0</b>, а <b>undefined – NaN</b>.<br><br>
        Посмотрим, какие забавные вещи случаются, когда мы применяем эти правила. И, что более важно, как избежать ошибок при их использовании.<br><br>
        <h2>Странный результат сравнения null и 0</h2>
        Сравним <b>null</b> с нулём:<br><br>
        alert( null > 0 );  // (1) false<br>
        alert( null == 0 ); // (2) false<br>
        alert( null >= 0 ); // (3) true<br><br>
        С точки зрения математики это странно. Результат последнего сравнения говорит о том, что "<b>null</b> больше или равно нулю", тогда результат одного из сравнений выше должен быть <b>true</b>, но они оба ложны.<br><br>
        Причина в том, что нестрогое равенство и сравнения <b>> < >= <=</b> работают по-разному. Сравнения преобразуют <b>null</b> в число, рассматривая его как 0. Поэтому выражение (3) <b>null >= 0</b> истинно, а <b>null > 0</b> ложно.<br><br>
        С другой стороны, для нестрогого равенства <b>==</b> значений <b>undefined</b> и <b>null</b> действует особое правило: эти значения ни к чему не приводятся, они равны друг другу и не равны ничему другому. Поэтому (2) <b>null == 0</b> ложно.<br><br>
    <h2>Несравненное значение undefined</h2>
        Значение </b>undefined</b> несравнимо с другими значениями:<br><br>
        alert( undefined > 0 ); // false (1)<br>
        alert( undefined < 0 ); // false (2)<br>
        alert( undefined == 0 ); // false (3)<br><br>
        Почему же сравнение </b>undefined</b> с нулём всегда ложно?<br><br>
        На это есть следующие причины:<br><br>
        Сравнения (1) и (2) возвращают <b>false</b>, потому что <b>undefined</b> преобразуется в <b>NaN</b>, а <b>NaN</b> – это специальное числовое значение, которое возвращает <b>false</b> при любых сравнениях.<br><br>
        Нестрогое равенство (3) возвращает <b>false</b>, потому что <b>undefined</b> равно только <b>null, undefined</b> и ничему больше.
    </p>
</section>
<section class="total">
<h2>Итог</h2>
<p >
    <ul>
  <li>Операторы сравнения возвращают значения логического типа.</li> 
<li> Строки сравниваются посимвольно в лексикографическом порядке.</li> 
<li> Значения разных типов при сравнении приводятся к числу. Исключением является сравнение с помощью операторов строгого равенства/неравенства.</li> 
<li>  Значения <b>null</b> и <b>undefined</b> равны <b>==</b> друг другу и не равны любому другому значению.</li> 
<li>  Будьте осторожны при использовании операторов сравнений вроде <b>></b> и <b><</b> с переменными, которые могут принимать значения <b>null/undefined</b>. Хорошей идеей будет сделать отдельную проверку на <b>null/undefined</b>.</li> 
</ul>
</p>
</section>